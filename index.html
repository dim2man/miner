<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>–°–∞–ø—ë—Ä</title>
	<style>
		* {font-family: Arial;font-size: 20px; box-sizing: border-box;}
		h1 {font-size: 2rem;text-align: center;}
		p {font-size: 1rem;text-align: center;}
		label {padding: 0.2rem 0.5rem;border: 2px outset #e3e3e3;background: #d0d0d0;}
		main {margin: auto;position: relative;}
		main > div {position: absolute;top: 0;left: 0;bottom: 0;right: 0;background-color: rgba(255,255,255,0.7);display: flex;justify-content: space-around;align-items: center;}
		table {margin: auto;}
		button {border-radius: 0;width: 1.4rem;height: 1.4rem;font-size: 0.8rem;vertical-align: middle;text-align: center;border: 2px outset #e3e3e3;color: black;background: #d0d0d0;}
		:checked + label, button.opened {border-style: inset;background: #e9e9e9;}
		button.expoited {background: #c00;}
		input, .hidden {display: none}
	</style>
	<script>
		// –£—Å—Ç–∞–Ω–æ–≤–∫–∏
		let ROWS = 5, COLS = 5, PCENT = 0.15, MODE = 'dig';
		try {
			const params = new URLSearchParams(location.search);
			if (params.has('rows')) ROWS = +params.get('rows');
			if (params.has('cols')) COLS = +params.get('cols');
			if (params.has('pcent')) PCENT = +params.get('pcent')/100;
			if (params.has('mode')) MODE = params.get('mode');
		} catch(e) {
			console.error('URLSearchParams failed or not supported');
		}
		// –°–æ—Å—Ç–æ—è–Ω–∏—è –∫–ª–µ—Ç–∫–∏
		const EMPTY = 0, MINE = 9;
		// –§–ª–∞–≥–∏ –∫–ª–µ—Ç–∫–∏
		const OPEN = 0x20, FLAG = 0x10;
		// –ö–∞—Ä—Ç–∏–Ω–∫–∏
		const SPACE = '\xa0', BOMB = 'üí£', TFLAG = 'üö©';
		// DOM
		let table, fail, victory, dig, flg;
		// data
		const field = new Array(ROWS);
		let timer = null;

		function checkVictory() {
			for(let i=0; i<ROWS; i++) {
				for(let j=0; j<COLS; j++) {
					if (!(field[i][j] & OPEN) && (field[i][j] & 0x0f) !== MINE) return;
				}
			}
			victory.classList.remove('hidden');
			for(let i=0; i<ROWS; i++) {
				for(let j=0; j<COLS; j++) {
					if ((field[i][j] & 0x0f) === MINE) {
						const button = table.rows[i].cells[j].firstChild;
						button.replaceChild(document.createTextNode(BOMB), button.firstChild);
						button.classList.add('opened');
					}
				}
			}
		}

		function scheduleCheckVictory() {
			if (timer) clearTimeout(timer);
			timer = setTimeout(checkVictory, 0);
		}

		function openCell(row, col) {
			if (!field[row] || typeof field[row][col] !== 'number') return 0;
			if (field[row][col] & OPEN || field[row][col] & FLAG) {
				return;
			}
			const button = table.rows[row].cells[col].firstChild;
			field[row][col] = field[row][col] ^ OPEN;
			button.classList.add('opened');
			if ((field[row][col] & 0x0f) === MINE) {
				for(let i=0; i<ROWS; i++) {
					for(let j=0; j<COLS; j++) {
						if ((field[i][j] & 0x0f) === MINE) {
							const button = table.rows[i].cells[j].firstChild;
							button.replaceChild(document.createTextNode(BOMB), button.firstChild);
							button.classList.add('opened');
						}
					}
				}
				button.classList.add('expoited');
				fail.classList.remove('hidden');
				return;
			}
			button.replaceChild(document.createTextNode((field[row][col] & 0x0f) || SPACE), button.firstChild);
			if ((field[row][col] & 0x0f) === EMPTY) {
				openNeighbors(row, col);
			}
			scheduleCheckVictory();
		}

		function openNeighbors(row, col) {
			openCell(row-1, col-1);
			openCell(row-1, col);
			openCell(row-1, col+1);
			openCell(row, col-1);
			openCell(row, col);
			openCell(row, col+1);
			openCell(row+1, col-1);
			openCell(row+1, col);
			openCell(row+1, col+1);
		}

		function handleClick(e) {
			e.preventDefault();
			const button = e.target;
			const row = Number(button.dataset.row);
			const col = Number(button.dataset.col);
			if (dig.checked) {
				openCell(row, col);
			} else {
				toggleFlag(row, col);
			}
		}

		function toggleFlag(row, col) {
			if (field[row][col] & OPEN) {
				// –∫–ª–∏–∫ –≤ —Ä–µ–∂–∏–º–µ —Ñ–ª–∞–≥–∞ –Ω–∞ –æ—Ç–∫—Ä—ã—Ç—É—é –∫–ª–µ—Ç–∫—É –æ—Ç–∫—Ä–æ–µ—Ç –≤—Å–µ –∑–∞–∫—Ä—ã—Ç—ã–µ –∫–ª–µ—Ç–∫–∏ –≤–æ–∫—Ä—É–≥ –Ω–µ—ë, –µ—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–ª–∞–≥–æ–≤ —Å–æ–≤–ø–∞–¥—ë—Ç —Å —á–∏—Å–ª–æ–º —Ä—è–¥–æ–º—Å—Ç–æ—è—â–∏—Ö –±–æ–º–±
				const cellValue = field[row][col] & 0x0f;
				if (cellValue === EMPTY) return;
				const flagCount = isFlag(row-1, col-1) + isFlag(row-1, col) + isFlag(row-1, col+1) + isFlag(row, col-1) + isFlag(row, col) + isFlag(row, col+1) + isFlag(row+1, col-1) + isFlag(row+1, col) + isFlag(row+1, col+1);
				if (cellValue === flagCount) {
					openNeighbors(row, col);
				}
				return;
			}
			field[row][col] = field[row][col] ^ FLAG;
			const button = table.rows[row].cells[col].firstChild;
			button.replaceChild(document.createTextNode(field[row][col] & FLAG ? TFLAG : SPACE), button.firstChild);
		}

		function genTable() {
			table.cellPadding = 0;
			table.cellSpacing = 0;
			for(let i=0; i<ROWS; i++) {
				const row = table.insertRow();
				for(let j=0; j<COLS; j++) {
					const col = row.insertCell();
					const button = document.createElement('button');
					button.appendChild(document.createTextNode(SPACE));
					button.dataset.row = i;
					button.dataset.col = j;
					button.addEventListener('click', handleClick);
					col.appendChild(button);
				}				
			}
		}

		function genField() {
			for(let i=0; i<ROWS; i++) {
				const cols = new Array(COLS);
				field[i] = cols;
				for(let j=0; j<COLS; j++) {
					cols[j] = EMPTY;
				}
			}
		}

		function isFlag(i, j) {
			if (!field[i] || typeof field[i][j] !== 'number') return 0;
			return field[i][j] & FLAG ? 1 : 0;
		}

		function isMine(i, j) {
			if (!field[i] || typeof field[i][j] !== 'number') return 0;
			return field[i][j] === MINE ? 1 : 0;
		}

		function genMines() {
			const pairs = new Array(ROWS*COLS);
			for(let i=0; i<ROWS; i++) {
				for(let j=0; j<COLS; j++) {
					pairs[i*COLS + j] = [i,j];
				}
			}
			const minecount = Math.round(pairs.length * PCENT);
			for(let i=0; i<minecount; i++) {
				const p = Math.floor(Math.random() * pairs.length);
				const pair = pairs[p];
				field[pair[0]][pair[1]] = MINE;
				pairs.splice(p, 1);
			}
			// —Å—á–∏—Ç–∞–µ–º —á–∏—Å–ª–æ –º–∏–Ω —Ä—è–¥–æ–º —Å –∫–ª–µ—Ç–∫–æ–π
			for(let i=0; i<ROWS; i++) {
				for(let j=0; j<COLS; j++) {
					if (field[i][j] === MINE) continue;
					field[i][j] = isMine(i-1, j-1) + isMine(i-1, j) + isMine(i-1, j+1) + isMine(i, j-1) + isMine(i, j) + isMine(i, j+1) + isMine(i+1, j-1) + isMine(i+1, j) + isMine(i+1, j+1);
				}
			}
		}

		function clickOnRandom(value = EMPTY) {
			const pairs = [];
			for(let i=0; i<ROWS; i++) {
				for(let j=0; j<COLS; j++) {
					if (field[i][j] === value) {
						pairs.push([i,j]);
					}
				}
			}
			if (pairs.length > 0) {
				const index = Math.floor(Math.random() * pairs.length);
				openCell(pairs[index][0], pairs[index][1]);
			} else {
				clickOnRandom(value+1);
			}
		}

		window.onload = function() {
			table = document.getElementsByTagName('table')[0];
			fail = document.getElementById('fail');
			victory = document.getElementById('victory');
			dig = document.getElementById('dig');
			genTable();
			genField();
			genMines();
			clickOnRandom();
			if (MODE === 'dig') {
				dig.click();
			} else {
				document.getElementById('flag').click();
			}
		}
	</script>
</head>
<body>
<h1>–ò–≥—Ä–∞ —Å–∞–ø—ë—Ä</h1>
<p><input id="dig" name="mode" type="radio" value="dig"><label for="dig">–†–∞—Å–∫–æ–ø</label><input id="flag" name="mode" type="radio" value="flag"><label for="flag">–§–ª–∞–≥</label></p>
<main>
<table></table>
<div id="fail" class="hidden"><div>–°–∞–ø—ë—Ä –æ—à–∏–±–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑...</div></div>
<div id="victory" class="hidden"><div>–ü–æ–±–µ–¥–∞!</div></div>
</main>
</body>
</html>